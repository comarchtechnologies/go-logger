// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	log "github.com/comarchtechnologies/go-logger"
)

type FakeLogger struct {
	DebugStub        func(...interface{})
	debugMutex       sync.RWMutex
	debugArgsForCall []struct {
		arg1 []interface{}
	}
	DebugfStub        func(string, ...interface{})
	debugfMutex       sync.RWMutex
	debugfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	DebuglnStub        func(...interface{})
	debuglnMutex       sync.RWMutex
	debuglnArgsForCall []struct {
		arg1 []interface{}
	}
	ErrorStub        func(...interface{})
	errorMutex       sync.RWMutex
	errorArgsForCall []struct {
		arg1 []interface{}
	}
	ErrorfStub        func(string, ...interface{})
	errorfMutex       sync.RWMutex
	errorfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	ErrorlnStub        func(...interface{})
	errorlnMutex       sync.RWMutex
	errorlnArgsForCall []struct {
		arg1 []interface{}
	}
	InfoStub        func(...interface{})
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		arg1 []interface{}
	}
	InfofStub        func(string, ...interface{})
	infofMutex       sync.RWMutex
	infofArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	InfolnStub        func(...interface{})
	infolnMutex       sync.RWMutex
	infolnArgsForCall []struct {
		arg1 []interface{}
	}
	WarnStub        func(...interface{})
	warnMutex       sync.RWMutex
	warnArgsForCall []struct {
		arg1 []interface{}
	}
	WarnfStub        func(string, ...interface{})
	warnfMutex       sync.RWMutex
	warnfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	WarnlnStub        func(...interface{})
	warnlnMutex       sync.RWMutex
	warnlnArgsForCall []struct {
		arg1 []interface{}
	}
	WithFieldsStub        func(log.Fields) log.Logger
	withFieldsMutex       sync.RWMutex
	withFieldsArgsForCall []struct {
		arg1 log.Fields
	}
	withFieldsReturns struct {
		result1 log.Logger
	}
	withFieldsReturnsOnCall map[int]struct {
		result1 log.Logger
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLogger) Debug(arg1 ...interface{}) {
	fake.debugMutex.Lock()
	fake.debugArgsForCall = append(fake.debugArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	stub := fake.DebugStub
	fake.recordInvocation("Debug", []interface{}{arg1})
	fake.debugMutex.Unlock()
	if stub != nil {
		fake.DebugStub(arg1...)
	}
}

func (fake *FakeLogger) DebugCallCount() int {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	return len(fake.debugArgsForCall)
}

func (fake *FakeLogger) DebugCalls(stub func(...interface{})) {
	fake.debugMutex.Lock()
	defer fake.debugMutex.Unlock()
	fake.DebugStub = stub
}

func (fake *FakeLogger) DebugArgsForCall(i int) []interface{} {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	argsForCall := fake.debugArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) Debugf(arg1 string, arg2 ...interface{}) {
	fake.debugfMutex.Lock()
	fake.debugfArgsForCall = append(fake.debugfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.DebugfStub
	fake.recordInvocation("Debugf", []interface{}{arg1, arg2})
	fake.debugfMutex.Unlock()
	if stub != nil {
		fake.DebugfStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) DebugfCallCount() int {
	fake.debugfMutex.RLock()
	defer fake.debugfMutex.RUnlock()
	return len(fake.debugfArgsForCall)
}

func (fake *FakeLogger) DebugfCalls(stub func(string, ...interface{})) {
	fake.debugfMutex.Lock()
	defer fake.debugfMutex.Unlock()
	fake.DebugfStub = stub
}

func (fake *FakeLogger) DebugfArgsForCall(i int) (string, []interface{}) {
	fake.debugfMutex.RLock()
	defer fake.debugfMutex.RUnlock()
	argsForCall := fake.debugfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Debugln(arg1 ...interface{}) {
	fake.debuglnMutex.Lock()
	fake.debuglnArgsForCall = append(fake.debuglnArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	stub := fake.DebuglnStub
	fake.recordInvocation("Debugln", []interface{}{arg1})
	fake.debuglnMutex.Unlock()
	if stub != nil {
		fake.DebuglnStub(arg1...)
	}
}

func (fake *FakeLogger) DebuglnCallCount() int {
	fake.debuglnMutex.RLock()
	defer fake.debuglnMutex.RUnlock()
	return len(fake.debuglnArgsForCall)
}

func (fake *FakeLogger) DebuglnCalls(stub func(...interface{})) {
	fake.debuglnMutex.Lock()
	defer fake.debuglnMutex.Unlock()
	fake.DebuglnStub = stub
}

func (fake *FakeLogger) DebuglnArgsForCall(i int) []interface{} {
	fake.debuglnMutex.RLock()
	defer fake.debuglnMutex.RUnlock()
	argsForCall := fake.debuglnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) Error(arg1 ...interface{}) {
	fake.errorMutex.Lock()
	fake.errorArgsForCall = append(fake.errorArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	stub := fake.ErrorStub
	fake.recordInvocation("Error", []interface{}{arg1})
	fake.errorMutex.Unlock()
	if stub != nil {
		fake.ErrorStub(arg1...)
	}
}

func (fake *FakeLogger) ErrorCallCount() int {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	return len(fake.errorArgsForCall)
}

func (fake *FakeLogger) ErrorCalls(stub func(...interface{})) {
	fake.errorMutex.Lock()
	defer fake.errorMutex.Unlock()
	fake.ErrorStub = stub
}

func (fake *FakeLogger) ErrorArgsForCall(i int) []interface{} {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	argsForCall := fake.errorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) Errorf(arg1 string, arg2 ...interface{}) {
	fake.errorfMutex.Lock()
	fake.errorfArgsForCall = append(fake.errorfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.ErrorfStub
	fake.recordInvocation("Errorf", []interface{}{arg1, arg2})
	fake.errorfMutex.Unlock()
	if stub != nil {
		fake.ErrorfStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) ErrorfCallCount() int {
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	return len(fake.errorfArgsForCall)
}

func (fake *FakeLogger) ErrorfCalls(stub func(string, ...interface{})) {
	fake.errorfMutex.Lock()
	defer fake.errorfMutex.Unlock()
	fake.ErrorfStub = stub
}

func (fake *FakeLogger) ErrorfArgsForCall(i int) (string, []interface{}) {
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	argsForCall := fake.errorfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Errorln(arg1 ...interface{}) {
	fake.errorlnMutex.Lock()
	fake.errorlnArgsForCall = append(fake.errorlnArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	stub := fake.ErrorlnStub
	fake.recordInvocation("Errorln", []interface{}{arg1})
	fake.errorlnMutex.Unlock()
	if stub != nil {
		fake.ErrorlnStub(arg1...)
	}
}

func (fake *FakeLogger) ErrorlnCallCount() int {
	fake.errorlnMutex.RLock()
	defer fake.errorlnMutex.RUnlock()
	return len(fake.errorlnArgsForCall)
}

func (fake *FakeLogger) ErrorlnCalls(stub func(...interface{})) {
	fake.errorlnMutex.Lock()
	defer fake.errorlnMutex.Unlock()
	fake.ErrorlnStub = stub
}

func (fake *FakeLogger) ErrorlnArgsForCall(i int) []interface{} {
	fake.errorlnMutex.RLock()
	defer fake.errorlnMutex.RUnlock()
	argsForCall := fake.errorlnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) Info(arg1 ...interface{}) {
	fake.infoMutex.Lock()
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	stub := fake.InfoStub
	fake.recordInvocation("Info", []interface{}{arg1})
	fake.infoMutex.Unlock()
	if stub != nil {
		fake.InfoStub(arg1...)
	}
}

func (fake *FakeLogger) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeLogger) InfoCalls(stub func(...interface{})) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeLogger) InfoArgsForCall(i int) []interface{} {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	argsForCall := fake.infoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) Infof(arg1 string, arg2 ...interface{}) {
	fake.infofMutex.Lock()
	fake.infofArgsForCall = append(fake.infofArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.InfofStub
	fake.recordInvocation("Infof", []interface{}{arg1, arg2})
	fake.infofMutex.Unlock()
	if stub != nil {
		fake.InfofStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) InfofCallCount() int {
	fake.infofMutex.RLock()
	defer fake.infofMutex.RUnlock()
	return len(fake.infofArgsForCall)
}

func (fake *FakeLogger) InfofCalls(stub func(string, ...interface{})) {
	fake.infofMutex.Lock()
	defer fake.infofMutex.Unlock()
	fake.InfofStub = stub
}

func (fake *FakeLogger) InfofArgsForCall(i int) (string, []interface{}) {
	fake.infofMutex.RLock()
	defer fake.infofMutex.RUnlock()
	argsForCall := fake.infofArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Infoln(arg1 ...interface{}) {
	fake.infolnMutex.Lock()
	fake.infolnArgsForCall = append(fake.infolnArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	stub := fake.InfolnStub
	fake.recordInvocation("Infoln", []interface{}{arg1})
	fake.infolnMutex.Unlock()
	if stub != nil {
		fake.InfolnStub(arg1...)
	}
}

func (fake *FakeLogger) InfolnCallCount() int {
	fake.infolnMutex.RLock()
	defer fake.infolnMutex.RUnlock()
	return len(fake.infolnArgsForCall)
}

func (fake *FakeLogger) InfolnCalls(stub func(...interface{})) {
	fake.infolnMutex.Lock()
	defer fake.infolnMutex.Unlock()
	fake.InfolnStub = stub
}

func (fake *FakeLogger) InfolnArgsForCall(i int) []interface{} {
	fake.infolnMutex.RLock()
	defer fake.infolnMutex.RUnlock()
	argsForCall := fake.infolnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) Warn(arg1 ...interface{}) {
	fake.warnMutex.Lock()
	fake.warnArgsForCall = append(fake.warnArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	stub := fake.WarnStub
	fake.recordInvocation("Warn", []interface{}{arg1})
	fake.warnMutex.Unlock()
	if stub != nil {
		fake.WarnStub(arg1...)
	}
}

func (fake *FakeLogger) WarnCallCount() int {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	return len(fake.warnArgsForCall)
}

func (fake *FakeLogger) WarnCalls(stub func(...interface{})) {
	fake.warnMutex.Lock()
	defer fake.warnMutex.Unlock()
	fake.WarnStub = stub
}

func (fake *FakeLogger) WarnArgsForCall(i int) []interface{} {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	argsForCall := fake.warnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) Warnf(arg1 string, arg2 ...interface{}) {
	fake.warnfMutex.Lock()
	fake.warnfArgsForCall = append(fake.warnfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.WarnfStub
	fake.recordInvocation("Warnf", []interface{}{arg1, arg2})
	fake.warnfMutex.Unlock()
	if stub != nil {
		fake.WarnfStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) WarnfCallCount() int {
	fake.warnfMutex.RLock()
	defer fake.warnfMutex.RUnlock()
	return len(fake.warnfArgsForCall)
}

func (fake *FakeLogger) WarnfCalls(stub func(string, ...interface{})) {
	fake.warnfMutex.Lock()
	defer fake.warnfMutex.Unlock()
	fake.WarnfStub = stub
}

func (fake *FakeLogger) WarnfArgsForCall(i int) (string, []interface{}) {
	fake.warnfMutex.RLock()
	defer fake.warnfMutex.RUnlock()
	argsForCall := fake.warnfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Warnln(arg1 ...interface{}) {
	fake.warnlnMutex.Lock()
	fake.warnlnArgsForCall = append(fake.warnlnArgsForCall, struct {
		arg1 []interface{}
	}{arg1})
	stub := fake.WarnlnStub
	fake.recordInvocation("Warnln", []interface{}{arg1})
	fake.warnlnMutex.Unlock()
	if stub != nil {
		fake.WarnlnStub(arg1...)
	}
}

func (fake *FakeLogger) WarnlnCallCount() int {
	fake.warnlnMutex.RLock()
	defer fake.warnlnMutex.RUnlock()
	return len(fake.warnlnArgsForCall)
}

func (fake *FakeLogger) WarnlnCalls(stub func(...interface{})) {
	fake.warnlnMutex.Lock()
	defer fake.warnlnMutex.Unlock()
	fake.WarnlnStub = stub
}

func (fake *FakeLogger) WarnlnArgsForCall(i int) []interface{} {
	fake.warnlnMutex.RLock()
	defer fake.warnlnMutex.RUnlock()
	argsForCall := fake.warnlnArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) WithFields(arg1 log.Fields) log.Logger {
	fake.withFieldsMutex.Lock()
	ret, specificReturn := fake.withFieldsReturnsOnCall[len(fake.withFieldsArgsForCall)]
	fake.withFieldsArgsForCall = append(fake.withFieldsArgsForCall, struct {
		arg1 log.Fields
	}{arg1})
	stub := fake.WithFieldsStub
	fakeReturns := fake.withFieldsReturns
	fake.recordInvocation("WithFields", []interface{}{arg1})
	fake.withFieldsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLogger) WithFieldsCallCount() int {
	fake.withFieldsMutex.RLock()
	defer fake.withFieldsMutex.RUnlock()
	return len(fake.withFieldsArgsForCall)
}

func (fake *FakeLogger) WithFieldsCalls(stub func(log.Fields) log.Logger) {
	fake.withFieldsMutex.Lock()
	defer fake.withFieldsMutex.Unlock()
	fake.WithFieldsStub = stub
}

func (fake *FakeLogger) WithFieldsArgsForCall(i int) log.Fields {
	fake.withFieldsMutex.RLock()
	defer fake.withFieldsMutex.RUnlock()
	argsForCall := fake.withFieldsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) WithFieldsReturns(result1 log.Logger) {
	fake.withFieldsMutex.Lock()
	defer fake.withFieldsMutex.Unlock()
	fake.WithFieldsStub = nil
	fake.withFieldsReturns = struct {
		result1 log.Logger
	}{result1}
}

func (fake *FakeLogger) WithFieldsReturnsOnCall(i int, result1 log.Logger) {
	fake.withFieldsMutex.Lock()
	defer fake.withFieldsMutex.Unlock()
	fake.WithFieldsStub = nil
	if fake.withFieldsReturnsOnCall == nil {
		fake.withFieldsReturnsOnCall = make(map[int]struct {
			result1 log.Logger
		})
	}
	fake.withFieldsReturnsOnCall[i] = struct {
		result1 log.Logger
	}{result1}
}

func (fake *FakeLogger) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	fake.debugfMutex.RLock()
	defer fake.debugfMutex.RUnlock()
	fake.debuglnMutex.RLock()
	defer fake.debuglnMutex.RUnlock()
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	fake.errorfMutex.RLock()
	defer fake.errorfMutex.RUnlock()
	fake.errorlnMutex.RLock()
	defer fake.errorlnMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.infofMutex.RLock()
	defer fake.infofMutex.RUnlock()
	fake.infolnMutex.RLock()
	defer fake.infolnMutex.RUnlock()
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	fake.warnfMutex.RLock()
	defer fake.warnfMutex.RUnlock()
	fake.warnlnMutex.RLock()
	defer fake.warnlnMutex.RUnlock()
	fake.withFieldsMutex.RLock()
	defer fake.withFieldsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLogger) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ log.Logger = new(FakeLogger)
